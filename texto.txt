"Contextualizando, DDD ou Domain Driven Design, que traduzindo é o design guiado pelo domínio, uma abordagem para modelagem de software que centraliza o desenvolvimento na criação de um modelo de domínio, ou seja, a criação da modelagem de software baseada em implementar modelos que refletem as competências da organização, a complexidade do negócio. Onde se fala dessa abordagem que muitas vezes é confundida com uma tecnologia, como se fosse um framework, ou como uma arquitetura. Mas nesse dicionário do programador, pretendemos retirar todas as suas dúvidas sobre DDD. Olá CDF, é um prazer ter você aqui novamente conosco. Já sabe que vamos te pedir pra curtir esse vídeo, né? Se essa é a sua primeira vez aqui no canal, eu sou o Gabriel e essa aqui é a minha esposa Vanessa. Somos um casal bem louco de programadores e jalecos, que todas as semanas está aqui destrinchando um termo ou uma tecnologia especialmente pra você. Já se inscreve e ativa o sininho para não perder as próximas notificações. Nesse episódio estamos falando de DDD, que até poderia ser Discagem Direta à Distância, mas o nosso DDD é o Domain Driven Design, que surgiu através de um livro, Domain Driven Design, atacando as complexidades no coração do software, lançado em 2003 por Eric Evans. Para tudo! Antes de continuar, vamos esclarecer um ponto bem básico mais importante. Quando falamos aqui de design, não estamos nos referindo ao visual nem a nada relacionado a layout da aplicação. O design do DDD é referente ao projeto. O DDD oferece ferramentas de modelagem estratégica e tática para entregar um software de alta qualidade, com o objetivo de acelerar o desenvolvimento de aplicações que lidam com processos e negócios complexos. Ela não é uma tecnologia ou uma metodologia. Pode ser utilizada independente da linguagem, não importa se é C Sharp ou Java. O DDD também não é arquitetura em camadas e não impõe processos rígidos ao time. Em seus princípios, o DDD é sobre discussão, escuta e compreensão. Todo um esforço para centralizar o conhecimento, transformando-o em modelos de domínio e em softwares que irão de verdade atender às necessidades e expectativas dos usuários. O próprio Eric Evans cita duas frases bem importantes sobre esse princípio. E os programadores não estão interessados no domínio, eles aprendem apenas o que a aplicação deve fazer e não os princípios por trás dela. Software útil pode até ser desenvolvido dessa maneira, mas o projeto nunca chegará em um ponto onde novas funcionalidades poderosas surgirão como desdobramento de funcionalidades existentes. Profundo e verdadeiro, mas talvez você ainda não tenha compreendido tão a fundo essa frase, mas ainda temos que explicar alguns dos conceitos por trás do Domain Driven Design, como o próprio domínio. Domínio me fez lembrar da hospedagem de sites, embora esse não seja o sentido que estamos abordando hoje por aqui, né? Mas vamos aproveitar para deixar um agradecimento especial à nossa parceira HostGator, que nos ajuda deveras a trazer cada vez mais conteúdo de qualidade para você. A HostGator é aquela parceira para toda hora, com uma equipe de suporte sempre pronta para te ajudar. Nosso link que te dá um desconto no serviço da HostGator está aqui embaixo na descrição. Voltando ao domínio. O domínio é o negócio da sua empresa ou o assunto do seu projeto. Existe ainda o Core Domain, que é a principal parte de um domínio. Eric deixa bem claro sua preocupação no entendimento do negócio e diz que entender o negócio é o único meio de implementar o DDD em um projeto. Nessa implementação existem basicamente dois papéis. O time de desenvolvimento, que somos nós mesmos, e o Domain Experts. Esses são os especialistas no negócio. Por exemplo, se estamos criando uma aplicação para auxiliar um escritório de advocacia, os advogados seriam os nossos Domain Experts. Eles seriam capazes de guiar a equipe para desenvolver um bom software, tirando dúvidas, definindo regras, processos e termos. Sendo assim, o desenvolvimento com o DDD é uma jornada de descoberto. Todos aprendem. Os devs com os Domain Experts e os Domain Experts com os devs. Falando em termos, esses são um dos pilares do DDD. Se especialistas da área e desenvolvedores devem trabalhar em conjunto, é preciso que ambos falem a mesma língua. Surge então a linguagem ubíqua, utilizada por toda a equipe do projeto. Imagina, nós desenvolvedores pensamos em classes, métodos, componentes, quais objetos criar, qual relacionamento entre eles. Pensamos em herança, polimorfismo e por aí vai. Os Domain Experts não entendem na dica de nada disso aí. Eles são especialistas no negócio, conhecem e sabem como a empresa deve funcionar. Só que, por sua vez, também falam um bando de termos que nós não fazemos ideia do que se trata. Por isso, a linguagem ubíqua é uma linguagem da equipe, compartilhada e principalmente entendida por todos. Durante o projeto, ela também vai evoluindo. O outro pilar é o Balnet Context, a delimitação do contexto. Ela é o limite conceitual. Uma vez que todo o domínio é colocado em um modelo, ela pode se tornar complexo demais. E o Balnet Context é justamente onde ela irá delimitar esses contextos, baseados nas intenções de negócios. Cada Balnet Context poderá ter a sua linguagem ubíqua, a sua abordagem de arquitetura, de armazenamento de dados e até a sua própria equipe de desenvolvimento. Esse é um exemplo de como os contextos de vendas e suporte se dividem. Dá pra ver que consumidor e produto aparecem duas vezes, mas em Balnet Context diferente. Isso significa que eles possuem papéis e responsabilidades diferentes dentro de cada contexto. O produto, no contexto de suporte, pode ser uma entidade com apenas um nome. Já em vendas, vamos precisar de mais informações, como valores, estoque, por exemplo. Então, em cada contexto, o produto possui características diferentes e provavelmente comportamentos também diferentes. Para criar esse modelo, entender como os Balnet Contexts se relacionam e como eles se comunicam, é utilizado o Context Map, um modelo que vai nos dar a visão geral do software. Existem alguns padrões de relacionamento entre os Balnet Contexts e eles implicam diretamente na estratégia de como os times do projeto irão trabalhar, na dependência entre eles, na arquitetura e até na estratégia de comunicação. Os principais tipos de relacionamentos entre contextos são o Shared Kernel, quando vários Balnet Contexts se compartilham de um mesmo domínio. Alterar ele significa que todas as equipes serão afetadas. Customer Supply Development, quando existe um relacionamento cliente-fornecedor, chamado no DVD de Downstream e Upstream, significa que a equipe Upstream pode ter êxito interdependente da equipe Downstream. Ou seja, um contexto é o fornecedor do serviço e o outro é o consumidor. Tecnicamente, as equipes irão definir testes de aceitação automatizados que irão validar as interfaces que a equipe Upstream fornece. Com isso, a equipe de fornecedores poderá fazer as modificações sem se preocupar em quebrar o sistema. Conforme-se nesse relacionamento, o Balnet Context Downstream está conformado que o modelo Upstream não atende suas necessidades. E o pior, que as modificações realizadas por ele irão impactar diretamente em seu contexto. Mas ele aceita o fato e se vira com o que tem, ficando aí atento a todas as mudanças realizadas. Partners, são aqueles Balnet Context que são parceiros. Pelo nome já tá pra saber, né? Estão unidos por uma dependência mútua e deverão trabalhar em conjunto. Que o Anti-Corruption Layer, nesse relacionamento à equipe Downstream, decide criar uma camada pra proteger o seu contexto das modificações do Upstream. É muito comum de ser encontrado em sistemas legados. E aí vai um modelo simplesão de Context Map pra esclarecer o assunto. Deu pra perceber que o desenho em si é bem simples mesmo. Um quadro branco e uma caneta já são suficientes pra criação desse modelo. Nele podemos ver os contextos da aplicação de gestão financeira, usuários web, o serviço de banco online e o de rastreamento de despesas. E as relações entre eles. Por exemplo, entre a aplicação de gestão financeira, o Downstream, e o serviço do banco online, o Upstream, existe uma camada de anti-corrupção. Já entre o contexto da aplicação de gestão financeira e o contexto de rastreamento de despesas, existe uma relação de parceria. Outros dois termos bem utilizados quando falamos de Domain Driven Design são o Design Estratégico e o Design Estático. O Design Estratégico ou Modelagem Estratégica é tudo o que já falamos. Na verdade, é bem difícil imaginar a implementação do DBD sem aplicar os conceitos da Modelagem Estratégica. Von Vernon, outro grande autor do assunto, disse que o Design Estratégico é como fazer o rascunho antes de entrar nos detalhes da implementação. Ele destaca o que é estrategicamente importante para o negócio, como dividir o trabalho por importância e como fazer integrações da melhor maneira. Já o Design Estático ou a Modelagem Estática diz respeito à implementação e usa o Domain Model Pattern, uma abordagem que diz como escrever as classes que irão mapear os modelos do mundo real e implementar os comportamentos do negócio. Existem também alguns padrões na Modelagem Estática, como, por exemplo, o Entities e o Value Objects, que definem os conceitos do domínio. O Domain Service, que assume responsabilidades que não se encaixam em outros projetos. Aggregates, que define fronteiras entre objetos. E o Factory e Repositories, que lida com a criação e armazenamento de objetos. É claro que criar um modelo para um sistema complexo não é uma tarefa fácil. É comum vermos modelos onde os limites são inconsistentes e que geram os conhecidos códigos macarrônicos, aquele sistema que ninguém quer mexer. Por isso, é importante não criarmos uma Big Ball of Mud, ou Grande Bola de Lama, que é impossível tocar sem se sujar. Para isso não acontecer, evite modelos abrangentes ou únicos. E cuidado com modelos com conceitos e nomes que tenham significado global, até porque será quase impossível estabelecer um acordo entre os diferentes Domain Experts. Poderíamos nos deliciar por mais algumas horas de vídeo se fôssemos explicar tudo o que envolve o DDD. Nossa dica para você que quer ir mais a fundo nesse assunto é ler o livro do Eric Ivan. Ele vai trazer um conjunto de práticas ideais do design, técnicas baseadas em experiências, princípios fundamentais e exemplos do DDD aplicado em projetos da vida real. É um daqueles livros que exige dedicação para a leitura, mas que vale a pena no final. Vamos deixar também nosso agradecimento especial ao Bruno Brito, que nos ajudou a criar esse conteúdo com seu artigo sobre Domain Driven Design. O link do artigo está aqui na descrição. Nós vamos ficando por aqui. Conta pra gente o que achou e deixa uma sugestão de tema pra um próximo Dicionário do Programador. E até a próxima. Tchau. Pra você não sentir saudade da gente, que tal dar uma olhadinha nesse outro vídeo aqui sobre DDD? Uma excelente sugestão. Test Driven Development. Que, na verdade, vem até do DDD. É verdade. Só nos falta falar de BDD. Cruzes. É o DDD, DDD, PDD... Menemê. Eu travo a língua danada, viu? Mas vai lá, assiste o DDD."